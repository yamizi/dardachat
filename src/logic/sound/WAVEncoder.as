package logic.sound{	import flash.utils.ByteArray;	import flash.utils.Endian;	/**	 * Liens :	 * - http://flash.mediabox.fr/index.php?showtopic=90410&st=30	 * - http://fr.wikipedia.org/wiki/WAVEform_audio_format	 * - http://www.sonicspot.com/guide/wavefiles.html	 * - http://ccrma.stanford.edu/CCRMA/Courses/422/projects/WaveFormat/	 * 	 */	public class WAVEncoder {		public function WAVEncoder() {		}		public function addHeaders(pSoundDatas:ByteArray,		pSampleRate:uint = 44100,		pChannels:uint = 1,		pBitsPerSample:uint = 16		):ByteArray {			var bytes: ByteArray = new ByteArray();			bytes.endian=Endian.LITTLE_ENDIAN;			// RIFF Chunk			bytes.writeUTFBytes( 'RIFF' );			// Chunk size : (fileSize) - 8			bytes.writeInt( pSoundDatas.length + 44 - 8 );// 44 le poids en o de l'en-tête			// Type of resource found in the RIFF			// WAV Chunk - Contains at least 2 chunks : "fmt"  and "data"			bytes.writeUTFBytes( 'WAVE' );			// fmt Chunk - describe how data are encoded and should be played			bytes.writeUTFBytes( 'fmt ' );			// Size of the chunk (16 + extra-datas size)			bytes.writeInt( 16 );			// Compression Code (1 = PCM/uncompressed)			bytes.writeShort( 1 );			// Number of channels			bytes.writeShort( pChannels );			// Sample rate			bytes.writeInt( pSampleRate );			// Average bytes per second : AvgBytesPerSec = SampleRate * BlockAlign			bytes.writeInt( pSampleRate * pChannels *  pBitsPerSample / 8 );			// Block Align = SignificantBitsPerSample / 8 * NumChannels 			bytes.writeShort( pChannels * pBitsPerSample / 8 );			// Significant bits per sample : number of bits used to define each sample (8, 16, 24 or 32)			bytes.writeShort( pBitsPerSample );			// data Chunk - Contains at least 2 chunks : "fmt"  and "data"			bytes.writeUTFBytes( 'data' );			// chunk size - audio datas size			//bytes.writeInt ( pSoundDatas.length ) ;			bytes.writeInt( pSoundDatas.length );			// Audio datas			bytes.writeBytes( pSoundDatas );			return bytes;		}	}}